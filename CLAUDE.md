# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview
This is an Unreal Engine 5.6 project named "Sandbox" - a development playground for testing and experimenting with UE5 features. The project uses C++ with additional UMG (UI) capabilities and includes plugins for ModelingTools, Water, and Landmass features.

## Build and Development Commands
- **Build solution**: Open `Sandbox.sln` in Visual Studio and build, or use UE5 Editor's compile button
- **Generate project files**: Right-click `Sandbox.uproject` â†’ "Generate Visual Studio project files"
- **Format code**: Uses `.clang-format` configuration (TabWidth: 4, ColumnLimit: 100, no tabs)
- **Run tests**: Test files located in subdirectories (e.g., `Source/Sandbox/core/levels/tests/`, `Source/Sandbox/containers/tests/`)

## Code Architecture and Structure

### Module Structure
The main game module is located in `Source/Sandbox/` with a feature-based organization:

#### Combat System (`combat/`)
- `effects/` - Combat-related effects
- `projectiles/` - Bullet and projectile implementations
- `weapons/` - Weapon systems and mechanics

#### Core Systems (`core/`)
- `camera/` - Camera systems and controls
- `console/` - Console commands and debugging
- `destruction/` - Destructible actor systems
- `levels/` - Level management and utilities
- `object_pooling/` - Object pooling for performance
- `video_settings/` - Graphics and video configuration
- `world_settings/` - World/level settings and configuration

#### Environment (`environment/`)
- `effects/` - Environmental effects
- `interactive/` - Interactive environment objects
- `obstacles/` - Obstacles and barriers
- `structures/` - Building and structure actors
- `traversal/` - Lifts, platforms, and traversal mechanics
- `utilities/` - Environment-related utilities

#### Game Flow (`game_flow/`)
- `actors/` - Game flow management actors
- `game_modes/` - Game mode implementations
- `game_states/` - Game state classes

#### Health System (`health/`)
- `actor_components/` - Health-related actor components
- `actors/` - Health-related actors (health packs, stations)
- `data/` - Health data structures
- `enums/` - Health-related enumerations
- `interfaces/` - Health system interfaces
- `subsystems/` - Health management subsystems

#### Inventory System (`inventory/`)
- `actor_components/` - Inventory actor components
- `actors/` - Inventory-related actors
- `data/` - Inventory data structures
- `enums/` - Inventory enumerations
- `interfaces/` - Inventory interfaces

#### Items System (`items/`)
- `actor_components/` - Item-related actor components
- `actors/` - Pickup actors and item entities
- `data/` - Item data assets
- `enums/` - Item type enumerations
- `interfaces/` - Item system interfaces

#### Input & Interaction
- `input/mixins/` - Input handling mixins
- `interaction/collision/` - Collision-based interactions
- `interaction/triggering/` - Trigger-based interactions

#### Logging System (`logging/`)
- `functions/` - Logging utility functions
- `mixins/` - Logging mixins
- `output_devices/` - Custom output device implementations
- `subsystems/` - Logging subsystems

#### Player Systems (`players/`)
- `common/` - Shared player functionality
- `npcs/` - Non-player character implementations
- `playable/` - Playable character classes and controllers

#### Movement (`movement/`)
- `actor_components/` - Movement-related components

#### Mass Entity System (`mass_entity/`)
- `data/` - Mass entity data structures
- `mixins/` - Mass entity system mixins
- `subsystems/` - Mass entity subsystems

#### UI System (`ui/`)
- `controllers/` - UI controllers
- `hud/` - HUD implementations
- `in_game_menu/` - In-game menu widgets
- `in_world/` - 3D in-world UI elements
- `main_menu/` - Main menu implementation
- `options_menu/` - Settings and options menus
- `styles/` - UI styling and themes
- `utilities/` - UI utility functions
- `widgets/` - Custom UMG widgets

#### Other
- `constants/` - Global constants
- `containers/` - Custom container implementations (with tests)
- `misc/learning/` - Learning/tutorial actors
- `shaders/` - Custom shader implementations
- `utilities/` - General utility functions, concepts, and macros
- `generated/` - Unreal-generated files

### Dependencies
- **Core modules**: Core, CoreUObject, Engine, InputCore, EnhancedInput, UMG
- **C++ Standard**: Latest C++ standard enabled
- **Engine version**: Unreal Engine 5.6
- **IMPORTANT**: ShaderCore and Renderer modules do not exist in UE 5.6 - do not add them to build dependencies

## Coding Standards

### Unreal Engine Code
- **Use UE 5.6 API**: Always reference Unreal Engine 5.6 documentation and API when writing code
- **Preserve UE conventions**: Keep autogenerated code style (e.g., `DeltaTime` in Tick, `GetOwner()` method names)
- **Don't rename UE methods**: Changing `GetOwner` to `get_owner` would break functionality
- **Respect engine patterns**: Follow UE naming for inherited/overridden methods
- **Check virtual function signatures**: Always verify override signatures match the base class in UE 5.6

### Custom Code Standards
- **snake_case**: For new methods and variables
- **TitleCase**: For class names
- **British English spelling**: Use British English spelling (colour, not color) for custom code
- **Brace initialization**: ALWAYS use `{}` for ALL local variable definitions - `int x{0};` instead of `int x = 0;`, `auto State{IsAdvancedViewChecked()};` instead of `auto State = IsAdvancedViewChecked();`, `TSharedPtr<SVerticalBox> PreviewBox{};` instead of `TSharedPtr<SVerticalBox> PreviewBox;`
- **Const placement**: Right of type - `int* const x{nullptr};`
- **auto usage**: Use everywhere unless explicit type is genuinely needed for a particular reason
- **const correctness**: Apply where appropriate, but don't force const on values that need to be mutable
- **Prefer references to pointers**: Use references instead of pointers where possible - `void foo(UWorld& world)` instead of `void foo(UWorld* world)` when the parameter cannot be null
- **Always use braces**: Even for single-line blocks - `if (x) { return; }`
- **Switch case braces**: Always use braces for switch case blocks - `case Foo: { statements; break; }`
- **No magic numbers**: Use `static constexpr` variables instead of literal numbers - `DrawDebugBox(..., debug_line_thickness)` not `DrawDebugBox(..., 2.0f)`
- **Follow `.clang-format`**: 100 character line limit, 4-space indentation
- **Comments**: Only add comments when the code itself doesn't easily make the meaning clear
- **Header organization**: Group includes in the following order, separated by blank lines:
  1. STL headers (e.g., `<vector>`, `<string>`)
  2. Unreal headers (e.g., `"CoreMinimal.h"`, `"Engine/World.h"`)
  3. Project headers (e.g., `"Sandbox/actors/MyActor.h"`)
  4. Macro headers from `macros/` directory (if they exist)
  5. Generated header (e.g., `"MyClass.generated.h"`) - only in header files for Unreal objects, must be last

### Architecture Principles
- **C++ for logic, Blueprints for visuals**: Keep game logic in C++, use Blueprints for visual elements and configuration
- **No asset instantiation in C++**: Don't create meshes or components in C++ - handle in Blueprints
- **Modular design**: Prefer actor components for reusable functionality
- **Performance first**: Spend time upfront building scalable systems rather than accumulating technical debt
- **Professional critique welcome**: Challenge ideas and suggest industry best practices

## Code Writing Policy
- **NEVER write or suggest code unless explicitly requested**: Only write, edit, or create code files when the user specifically asks for implementation
- **Analysis and explanation only by default**: Provide code analysis, explanations, and guidance without writing code
- **Wait for explicit requests**: The user will clearly state when they want code to be written or modified
- **Keep implementations minimal and lean**: When writing code, implement only what was explicitly requested. Do not add extra features, error handling, debug functionality, or other enhancements unless specifically asked for them
- **Always run format-cpp.py after code changes**: When making any code modifications, run `python format-cpp.py` at the end of a set of edits to format all C++ files instead of running clang-format individually per file
- **DO NOT attempt to test Unreal Engine code**: Testing UE5 C++ code requires the engine and project compilation which is not available in this environment
- **Cannot edit Blueprint files**: Blueprint assets (.uasset files) are binary and cannot be modified directly - provide instructions for user to implement in UE5 Editor