#pragma once

/*
Warning: This is an autogenerated file.
*/

// clang-format off
#include <array>
#include <functional>
#include <utility>

#include "CoreMinimal.h"

#include "player_skills.generated.h"

UENUM(BlueprintType)
enum class EPlayerSkillName : uint8 {
    // Attribute
    Strength UMETA(DisplayName = "Strength"),
    Endurance UMETA(DisplayName = "Endurance"),
    Agility UMETA(DisplayName = "Agility"),
    Cyber UMETA(DisplayName = "Cyber"),
    Psi UMETA(DisplayName = "Psi"),
    // Tech
    hacking UMETA(DisplayName = "Hacking"),
    // Weapon
    small_guns UMETA(DisplayName = "Small Guns"),
};
namespace ml {
// Attribute
// ----------------------------------------------------------------------
inline constexpr int32 num_attribute_values{5};
// Index functions for looping
inline constexpr int32 attribute_start_index{0};
// The last index (inclusive)
inline constexpr int32 attribute_last_index{4};
// The index after the last index 
inline constexpr int32 attribute_end_index{5};

inline constexpr auto is_attribute(EPlayerSkillName value) -> bool {
    auto const x{std::to_underlying(value)}; 
    constexpr auto lower{
        std::to_underlying(EPlayerSkillName::Strength)
    };
    constexpr auto upper{
        std::to_underlying(EPlayerSkillName::Psi)
    };
    
    return ((x >= lower) && (x <= upper));
}

inline constexpr std::array<EPlayerSkillName, 5> attribute_values{{
    EPlayerSkillName::Strength,
    EPlayerSkillName::Endurance,
    EPlayerSkillName::Agility,
    EPlayerSkillName::Cyber,
    EPlayerSkillName::Psi
}};


// Tech
// ----------------------------------------------------------------------
inline constexpr int32 num_tech_values{1};
// Index functions for looping
inline constexpr int32 tech_start_index{5};
// The last index (inclusive)
inline constexpr int32 tech_last_index{5};
// The index after the last index 
inline constexpr int32 tech_end_index{6};

inline constexpr auto is_tech(EPlayerSkillName value) -> bool {
    auto const x{std::to_underlying(value)}; 
    constexpr auto lower{
        std::to_underlying(EPlayerSkillName::hacking)
    };
    constexpr auto upper{
        std::to_underlying(EPlayerSkillName::hacking)
    };
    
    return ((x >= lower) && (x <= upper));
}

inline constexpr std::array<EPlayerSkillName, 1> tech_values{{
    EPlayerSkillName::hacking
}};


// Weapon
// ----------------------------------------------------------------------
inline constexpr int32 num_weapon_values{1};
// Index functions for looping
inline constexpr int32 weapon_start_index{6};
// The last index (inclusive)
inline constexpr int32 weapon_last_index{6};
// The index after the last index 
inline constexpr int32 weapon_end_index{7};

inline constexpr auto is_weapon(EPlayerSkillName value) -> bool {
    auto const x{std::to_underlying(value)}; 
    constexpr auto lower{
        std::to_underlying(EPlayerSkillName::small_guns)
    };
    constexpr auto upper{
        std::to_underlying(EPlayerSkillName::small_guns)
    };
    
    return ((x >= lower) && (x <= upper));
}

inline constexpr std::array<EPlayerSkillName, 1> weapon_values{{
    EPlayerSkillName::small_guns
}};

// String functions
inline auto get_display_name(EPlayerSkillName value) -> FName {
    switch (value) {
        case EPlayerSkillName::Strength: {
            static FName const name{TEXT("Strength")};
            return name;
        }
        case EPlayerSkillName::Endurance: {
            static FName const name{TEXT("Endurance")};
            return name;
        }
        case EPlayerSkillName::Agility: {
            static FName const name{TEXT("Agility")};
            return name;
        }
        case EPlayerSkillName::Cyber: {
            static FName const name{TEXT("Cyber")};
            return name;
        }
        case EPlayerSkillName::Psi: {
            static FName const name{TEXT("Psi")};
            return name;
        }
        case EPlayerSkillName::hacking: {
            static FName const name{TEXT("Hacking")};
            return name;
        }
        case EPlayerSkillName::small_guns: {
            static FName const name{TEXT("Small Guns")};
            return name;
        }
        default: {
            break;
        }
    }

    static auto const unhandled_name{FName{TEXT("UNHANDLED_CASE")}};
    return unhandled_name;
}
inline auto get_display_string(EPlayerSkillName value) -> FString const& {
    switch (value) {
        case EPlayerSkillName::Strength: {
            static FString const name{get_display_name(value).ToString()};
            return name;
        }
        case EPlayerSkillName::Endurance: {
            static FString const name{get_display_name(value).ToString()};
            return name;
        }
        case EPlayerSkillName::Agility: {
            static FString const name{get_display_name(value).ToString()};
            return name;
        }
        case EPlayerSkillName::Cyber: {
            static FString const name{get_display_name(value).ToString()};
            return name;
        }
        case EPlayerSkillName::Psi: {
            static FString const name{get_display_name(value).ToString()};
            return name;
        }
        case EPlayerSkillName::hacking: {
            static FString const name{get_display_name(value).ToString()};
            return name;
        }
        case EPlayerSkillName::small_guns: {
            static FString const name{get_display_name(value).ToString()};
            return name;
        }
        default: {
            break;
        }
    }

    static FString const unhandled_name{TEXT("UNHANDLED_CASE")};
    return unhandled_name;
}
inline auto get_display_string_view(EPlayerSkillName value) -> TStringView<TCHAR> {
    return get_display_string(value);
}

} // namespace ml

USTRUCT(BlueprintType)
struct FPlayerSkill {
    GENERATED_BODY()
  public:
    FPlayerSkill() = default;
    FPlayerSkill(uint8 skill_, uint8 max_)
        : skill_(skill_)
        , max_(max_)
    {}

    auto get(this auto const& self) {
        return self.skill_;
    }
    auto set(this auto& self, uint8 input) {
        self.skill_ = std::min(input, self.max_);
    }
    auto inc(this auto& self) {
        self.set(self.skill_ + uint8{1});
    }
  private:
    UPROPERTY(EditAnywhere, Category="Player")
    uint8 skill_{1};
    UPROPERTY(EditAnywhere, Category="Player")
    uint8 max_{1};
};

USTRUCT(BlueprintType)
struct FPlayerSkills {
    GENERATED_BODY()
  public:
    struct SkillView {
        FPlayerSkill& skill;
        FString const& name;
        EPlayerSkillName enum_key;

        SkillView() = delete;
        SkillView(EPlayerSkillName enum_key, 
                  FString const& name, 
                  FPlayerSkill& skill)
            : skill(skill)
            , name(name)
            , enum_key(enum_key)
        {};
    };
    template <EPlayerSkillName skill_type, typename Self>
    constexpr auto get_value(this Self const& self) {
        return self.skills_[std::to_underlying(skill_type)].get();
    }
    template <typename Self>
    constexpr auto get_value(this Self const& self, EPlayerSkillName skill_type) {
        return self.skills_[std::to_underlying(skill_type)].get();
    }
    template <EPlayerSkillName skill_type, typename Self>
    constexpr auto get(this Self&& self) -> auto&& {
        return std::forward_like<Self>(self.skills_[std::to_underlying(skill_type)]);
    }
    template <typename Self>
    constexpr auto get(this Self const& self, EPlayerSkillName skill_type) -> auto&& {
        return std::forward_like<Self>(self.skills_[std::to_underlying(skill_type)]);
    }
    template <EPlayerSkillName skill_type, typename Self>
    auto get_view(this Self& self) {
        return SkillView{
            skill_type,
            ml::get_display_string(skill_type),
            self.get<skill_type>()
        };
    }
    template <EPlayerSkillName skill_type, typename Self>
    constexpr void set(this Self& self, uint8 value) {
        self.get<skill_type>.set(value);    
    }
    constexpr void set(this auto& self, EPlayerSkillName skill_type, uint8 value) {
        self.get<skill_type>.set(value);
    }
    // Attribute
    auto get_strength_view() { return get_view<EPlayerSkillName::Strength>(); }
    auto get_endurance_view() { return get_view<EPlayerSkillName::Endurance>(); }
    auto get_agility_view() { return get_view<EPlayerSkillName::Agility>(); }
    auto get_cyber_view() { return get_view<EPlayerSkillName::Cyber>(); }
    auto get_psi_view() { return get_view<EPlayerSkillName::Psi>(); }
    // Tech
    auto get_hacking_view() { return get_view<EPlayerSkillName::hacking>(); }
    // Weapon
    auto get_small_guns_view() { return get_view<EPlayerSkillName::small_guns>(); }
    // Category views
    auto get_attribute_view(this auto& self) -> std::array<SkillView, 5> {
        return {{
            get_strength_view(),
            get_endurance_view(),
            get_agility_view(),
            get_cyber_view(),
            get_psi_view()
        }};
    }
    auto get_tech_view(this auto& self) -> std::array<SkillView, 1> {
        return {{
            get_hacking_view()
        }};
    }
    auto get_weapon_view(this auto& self) -> std::array<SkillView, 1> {
        return {{
            get_small_guns_view()
        }};
    }
  private:
    std::array<FPlayerSkill, 7> skills_{{
        // Strength
        {uint8{1}, uint8{10}},
        // Endurance
        {uint8{1}, uint8{10}},
        // Agility
        {uint8{1}, uint8{10}},
        // Cyber
        {uint8{1}, uint8{10}},
        // Psi
        {uint8{1}, uint8{10}},
        // hacking
        {uint8{1}, uint8{10}},
        // small_guns
        {uint8{1}, uint8{10}}
    }};
};
// clang-format on
